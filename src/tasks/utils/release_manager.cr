require "totem"
require "colorize"
require "./sample_utils.cr"
require "logger"
require "halite"

module ReleaseManager 
  module GithubReleaseManager
    def self.github_releases : Array(JSON::Any)
      existing_releases = Halite.basic_auth(user: ENV["GITHUB_USER"], pass: ENV["GITHUB_TOKEN"]).
        get("https://api.github.com/repos/cncf/cnf-conformance/releases", 
            headers: {Accept: "application/vnd.github.v3+json"})
      JSON.parse(existing_releases.body).as_a
    end 


    def self.upsert_release(version=nil) : Tuple((JSON::Any | Nil), (JSON::Any | Nil))
      LOGGING.info "upsert_release"
      found_release : (JSON::Any | Nil) = nil
      asset : (JSON::Any | Nil) = nil
      upsert_version = (version || CnfConformance::VERSION)
      if upsert_version =~ /(?i)(master)/
        prerelease = false
      else
        prerelease = true
      end
      if ReleaseManager.remote_master_branch_hash == ReleaseManager.current_hash
        upsert_version = upsert_version.sub("HEAD", "master")
      end
      unless upsert_version =~ /(?i)(master|v[0-1]|test_version)/
        LOGGING.info "Not creating a release for : #{upsert_version}"
        return {found_release, asset} 
      end
      LOGGING.info "upsert_version: #{upsert_version}"
      release_resp = ReleaseManager::GithubReleaseManager.github_releases
      LOGGING.info "release_resp size: #{release_resp.size}"

      found_release = release_resp.find {|x| x["tag_name"] == upsert_version} 
      LOGGING.info "find found_release?: #{found_release}"

notes_template = <<-TEMPLATE
UPDATES
---

TODO!: Fill out release notes!

Artifact info:
- Commit: FIXME!
- SHA256SUM: FIXME! cnf-conformance-FIXME!

TEMPLATE

      unless found_release
        # /repos/:owner/:repo/releases
        found_resp = Halite.basic_auth(user: ENV["GITHUB_USER"], pass: ENV["GITHUB_TOKEN"]).
          post("https://api.github.com/repos/cncf/cnf-conformance/releases",
               headers: {Accept: "application/vnd.github.v3+json"},
               json: { "tag_name" => upsert_version,
                       "draft" => true,
                       "prerelease" => prerelease, 
                       "name" => "#{upsert_version} #{Time.local.to_s("%B, %d %Y")}",
                       "body" => notes_template })
        found_release = JSON.parse(found_resp.body)
        # TODO error if cant create a release
        LOGGING.info "(unless) found_release: #{found_release}"
      end

      # PATCH /repos/:owner/:repo/releases/:release_id
      found_resp = Halite.basic_auth(user: ENV["GITHUB_USER"], pass: ENV["GITHUB_TOKEN"]).
        patch("https://api.github.com/repos/cncf/cnf-conformance/releases/#{found_release["id"]}",
              json: { "tag_name" => upsert_version,
                      "draft" => true,
                      "prerelease" => prerelease,
                      "name" => "#{upsert_version} #{Time.local.to_s("%B, %d %Y")}",
                      "body" => notes_template })
      found_release = JSON.parse(found_resp.body)

      LOGGING.info "found_release (after create): #{found_release}"
      LOGGING.info "found_release id: #{found_release["id"]}"

      # Build a static binary so it will be portable on other machines
      unless ENV["CRYSTAL_ENV"]? == "TEST"
        rm_resp = `rm ./cnf-conformance`
        LOGGING.info "rm_resp: #{rm_resp}"
        build_resp = `crystal build src/cnf-conformance.cr --release --static --link-flags "-lxml2 -llzma"`
        LOGGING.info "build_resp: #{build_resp}"
      end

      cnf_bin_path = "cnf-conformance"
      cnf_bin_asset_name = `#{cnf_bin_path}`

      unless ENV["CRYSTAL_ENV"]? == "TEST"
        cnf_bin_asset_name = `#{cnf_bin_path}-static`
      end
       # asset = JSON.parse(asset_resp.body)

      # NOTE: so I wrote all this code... and then recognized tarballs and zips of the source
      # are automatically generated by github whenever you PUBLISH a release...
      # note that is AFTER you hit publish. before their won't be and you can double check this
      # by editing and already existing release
      #
      # left this code just in case or in case we want to upload other stuff
      #
      ## source_tarball_name = "cnf-conformance-#{upsert_version}"
      ## `git archive -o #{source_tarball_name} --format=tar.gz $(git rev-parse --abbrev-ref HEAD)`
      ## `git archive -o #{source_tarball_name} --format=zip $(git rev-parse --abbrev-ref HEAD)`

      ## LOGGING.info "source_tarball: #{source_tarball_name}"
      ## source_tarball_path = `#{source_tarball_name}.tar.gz`
      ## source_zip_path = `#{source_tarball_name}.zip`

      ## LOGGING.info "uploading binary"
      ## bin_asset_resp = ReleaseManager.upload_release_asset(found_release["id"], cnf_bin_path, cnf_bin_asset_name)
      ## LOGGING.info "uploading source tarball"
      ## source_tarball_asset_resp = ReleaseManager.upload_release_asset(found_release["id"], source_tarball_path, source_tarball_path)
      ## LOGGING.info "uploading source zip"
      ## source_zip_asset_resp = ReleaseManager.upload_release_asset(found_release["id"], source_zip_path, source_zip_path)

      ## const assets = [bin_asset_resp, source_tarball_asset_resp, source_zip_asset_resp]

      LOGGING.info "uploading binary"
      asset = ReleaseManager.upload_release_asset(found_release["id"], cnf_bin_path, cnf_bin_asset_name)
      {found_release, asset}
    end

    def self.delete_release(version)
      # DELETE /repos/:owner/:repo/releases/assets/:asset_id
      # DELETE /repos/:owner/:repo/releases/:release_id
      release_resp = ReleaseManager::GithubReleaseManager.github_releases
      puts "this is the version #{version}"
      found_release = release_resp.find {|x| x["tag_name"] == "#{version}"} 
      puts "this is found_release #{typeof(found_release)}"
      if found_release
        puts "this is found_release id #{found_release["id"]}"
        resp = Halite.basic_auth(user: ENV["GITHUB_USER"], pass: ENV["GITHUB_TOKEN"]).
          delete("https://api.github.com/repos/cncf/cnf-conformance/releases/#{found_release["id"]}")
        resp_code = resp.status_code
        LOGGING.info "resp_code: #{resp_code}"
      else 
        resp_code = 404
      end 
      resp_code
    end 

    #TODO get github secrets and add them to the CI (e.g. travis) secrets list 
  end
  module CompileTimeVersionGenerater
    macro tagged_version
      {% current_branch = `git rev-parse --abbrev-ref HEAD` %}
      {% current_hash = `git rev-parse --short HEAD` %}
      {% current_tag = `git tag --points-at HEAD` %}
      {% if current_tag.strip == "" %}
        VERSION = "{{current_branch.strip}}-{{current_hash.strip}}"
      {% else %}
        VERSION = "{{current_tag.strip}}"
      {% end %}
    end
  end

  def self.tag(options="")
    results = `git tag #{options}`
    LOGGING.info "git tag: #{results}"
    results.split("\n")
  end

  def self.on_a_tag?
    ReleaseManager.tag("--points-at HEAD") != [""]
  end

  def self.current_tag
    ReleaseManager.tag("--points-at HEAD")
  end

  def self.current_branch
    results = `git rev-parse --abbrev-ref HEAD`
    LOGGING.info "current_branch rev-parse: #{results}"
    results.strip("\n")
  end

  def self.current_hash
    results = `git rev-parse --short HEAD`
    LOGGING.info "current_hash rev-parse: #{results}"
    results.strip("\n")
  end

  def self.remote_master_branch_hash(owner_repo="cncf/cnf-conformance")
    results =  `git ls-remote https://github.com/#{owner_repo}.git master | awk '{ print $1}' | cut -c1-7`.strip
    LOGGING.info "remote_master_branch_hash: #{results}"
    results.strip("\n")
  end

  def self.upload_release_asset(release_id, asset_path, asset_name)
      # TODO Add test that checks for uploaded corrupted binary.
      # POST :server/repos/:owner/:repo/releases/:release_id/assets{?name,label}
      # asset_resp = Halite.basic_auth(user: ENV["GITHUB_USER"], pass: ENV["GITHUB_TOKEN"]).
      #   post("https://uploads.github.com/repos/cncf/cnf-conformance/releases/#{found_release["id"]}/assets?name=#{cnf_tarball_name}",
      #        headers: {
      #           "Content-Type" => "application/gzip",
      #           "Content-Length" => File.size("#{cnf_tarball_name}").to_s
      #   }, raw: "#{File.open("#{cnf_tarball_name}")}")A
    asset_resp = `curl -u #{ENV["GITHUB_USER"]}:#{ENV["GITHUB_TOKEN"]} -H "Content-Type: $(file -b --mime-type #{asset_path})" --data-binary @#{asset_path} "https://uploads.github.com/repos/cncf/cnf-conformance/releases/#{release_id}/assets?name=$(basename #{asset_name})"`
    asset = JSON.parse(asset_resp.strip)
    LOGGING.info "asset: #{asset}"
    asset
  end
end 
